Problem Description
近期B厂组织了一次大搬家，所有人都要按照指示换到指定的座位上。指示的内容是坐在位置i上的人要搬到位置j上。现在B厂有N个人，一对一到N个位置上。搬家之后也是一一对应的，改变的只有位次。

在第一次搬家后，度度熊由于疏忽，又要求大家按照原指示进行了一次搬家。于是，机智的它想到：再按这个指示搬一次家不就可以恢复第一次搬家的样子了。于是，B厂史无前例的进行了连续三次搬家。

虽然我们都知道度度熊的“机智”常常令人堪忧，但是不可思议的是，这回真的应验了。第三次搬家后的结果和第一次的结果完全相同。

那么，有多少种指示会让这种事情发生呢？如果两种指示中至少有一个人的目标位置不同，就认为这两种指示是不相同的。
Input
第一行一个整数T，表示T组数据。

每组数据包含一个整数N(1≤N≤1000000)。
Output
对于每组数据，先输出一行 Case #i: 然后输出结果，对1000000007取模。
Sample Input
2
1
3
Sample Output
Case #1:
1
Case #2:
4

解析：
采用递推的方法，大概能够看到其中的策略：元素映射自己可以达到目的，两个元素互相映射也可以达到目的。
假设N个座位的结果为d(N)。d(N)可以拆分为两个子问题：1、第N个元素映射自己，2、第N个元素不映射自己。
子问题1：很容易，其解即为d(N-1)。
子问题2：第N个元素可以映射剩余的N-1个元素中的一个，有N-1种选择。选中一组之后，现在还剩余N-2个元素，这N-2个元素有多少解呢？答案是d(N-2)，因此解为(N-1)*d(N-2)。
递推公式： d(N) = d(N-1) + (N-1)*d(N-2)

源码如下：
// 递推公式: d(N) = d(N-1) + C(1, N-1)*d(N-2) = d(N-1) + (N-1)*d(N-2)
#include <cstdio>
const int MOD = 1e9 + 7;
const int maxn = 1e6 + 10;
long long d[maxn];
int main() {
	d[1] = 1;
	d[2] = 2;
	for(int i = 3; i < maxn; i++)
		d[i] = (d[i-1] + (i-1)*d[i-2]%MOD) % MOD;
	int T, cnt = 0;
	scanf("%d", &T);
	while(T--) {
		int N;
		scanf("%d", &N);
		printf("Case #%d:\n%d\n", ++cnt, d[N]);
	}
	return 0;
}
